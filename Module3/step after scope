/*
 * main.c -- A program to print a dot each time button 0 is pressed.
 *
 *  Some useful values:
 */
#include <stdio.h>		/* getchar,printf */
#include <stdlib.h>		/* strtod */
#include <stdbool.h>		/* type bool */
#include <unistd.h>		/* sleep */
#include <string.h>

#include "platform.h"		/* ZYBO board interface */
#include "xil_types.h"		/* u32, s32 etc */
#include "xparameters.h"	/* constants used by hardware */
#include "xtmrctr.h"


#include "gic.h"		/* interrupt controller interface */
#include "xgpio.h"		/* axi gpio interface */
#include "led.h" // led interface
#include "io.h" //
#include "ttc.h"




/* hidden private state */
//static XGpio btnport;	       /* btn GPIO port instance */
// static int pushes=0;	       /* variable used to count interrupts */
//static bool pushed = false; 			// true when a button goes from low to high

#define LINELEN 32
#define FREQ 1 // 1 hz = 1 sec
#define LED4 4

#define PERIOD 1000000
#define HIGHTIME 75000

void read_save_echo_line(char line[]){
    char c;
    int i = 0; // where to save read char in line
    c = getchar();

    // \r is carriage return which is what lines end with in this system
    // https://developer.arm.com/documentation/ka003309/latest#:~:text=In%20most%20C%20compilers%2C%20including,return%20is%20'%5Cr'.
    while (c != '\r'){
        // save read char
        *(line + i) = c;
        i++;

        // echo back read char
        putchar(c);

        // read new char
        c = getchar();
    }
    // null terminate line after reaching a new line char
    *(line+i) = '\0';
}


// toggle led 4
static void ttc_callback(void){
	if (led_get(LED4) == LED_ON){
		led_set(4, LED_OFF);
	}else{
		led_set(4, LED_ON);
	}
}

void btn_callback(u32 btn) {
	led_toggle(btn);
	//pushes++;
}


static XTmrCtr psTmr;

int main() {
  /* variables
   *
   */

	printf("[hello]\n");
	fflush(stdout);
	char line[LINELEN];
	bool done = false;
	char* end_char; // first non-integer char of a line (used in strtol())
	int strtol_n; // strtol return

	// initialize platform
	init_platform();
	// initialize gic
	gic_init();
	// initialize buttons
	io_btn_init(btn_callback);
	// initialize switches
	io_sw_init(btn_callback);
	// initialize leds
	led_init();
	// initialize and start ttc
	ttc_init(FREQ, ttc_callback);
	ttc_start();



//	XTmrCtr_CfgInitialize(XTmrCtr *InstancePtr, XTmrCtr_Config *ConfigPtr, UINTPTR EffectiveAddr)

	if (XTmrCtr_Initialize(&psTmr, XPAR_AXI_TIMER_0_DEVICE_ID) != XST_SUCCESS){
		printf("Unable to initilize PS timer");
		fflush(stdout);
	}
	printf("[hello]\n");
	fflush(stdout);
	// test theory
	XTmrCtr_Stop(&psTmr, 0);
	XTmrCtr_Stop(&psTmr, 1);


	XTmrCtr_SetOptions(&psTmr, 0, XTC_PWM_ENABLE_OPTION | XTC_DOWN_COUNT_OPTION | XTC_EXT_COMPARE_OPTION);
	XTmrCtr_SetOptions(&psTmr, 1, XTC_PWM_ENABLE_OPTION | XTC_DOWN_COUNT_OPTION | XTC_EXT_COMPARE_OPTION);

	XTmrCtr_SetResetValue(&psTmr, 0,  PERIOD);
	XTmrCtr_SetResetValue(&psTmr, 1, HIGHTIME);

	XTmrCtr_Start(&psTmr, 0);
	XTmrCtr_Start(&psTmr, 1);




	//set led 4 on to signify program is on
	led_set(4, LED_ON);

	printf("[hello]\n"); /* so we are know its alive */


	// listening for stdin
	while(!done){

			printf(">");
			// write everything in stdout buffer in case
			fflush(stdout);

			read_save_echo_line(line);

			if (strcmp(line, "q") == 0){
				done = true;

			}else{
				strtol_n = (int)strtol(line, &end_char, 10); // convert the content of line to base 10
				/*
		           detect a number between 0 and 3
		               man strtol:
		               If endptr is not NULL, strtol() stores the address of the first invalid
		               character  in *endptr.  If there were no digits at all, strtol() stores
		               the original value of nptr in *endptr (and returns 0).  In  particular,
		               if  *nptr is not '\0' but **endptr is '\0' on return, the entire string
		               is valid.
				 */
				if (*line != '\0' && *end_char == '\0'){ //or *end_char == '\0' && line != end_char && n >=0){
					if (strtol_n >= 0 && strtol_n <= 3){
						// Step 9: Toggle the expected LED & print
						led_toggle((u32)strtol_n);
					}
				}
			}
			printf("\n");
		}


	printf("\n[done]\n");

	ttc_stop();
	ttc_close();
	io_btn_close();
	io_sw_close();
	gic_close();
	led_set(ALL, LED_OFF); // turn off led0
	led_set(4, LED_OFF);
	cleanup_platform();					/* cleanup the hardware platform */
	return 0;
}
